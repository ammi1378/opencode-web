/**
 * Generated by orval v7.15.0 üç∫
 * Do not edit manually.
 * opencode
 * opencode api
 * OpenAPI spec version: 0.0.3
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'

import type {
  Agent,
  AppAgentsParams,
  AppLogBody,
  AppLogParams,
  AssistantMessage,
  Auth,
  AuthSetParams,
  BadRequestError,
  Command,
  CommandListParams,
  Config,
  ConfigGetParams,
  ConfigProviders200,
  ConfigProvidersParams,
  ConfigUpdateParams,
  Event,
  EventSubscribeParams,
  File,
  FileContent,
  FileDiff,
  FileListParams,
  FileNode,
  FileReadParams,
  FileStatusParams,
  FindFilesParams,
  FindSymbolsParams,
  FindText200Item,
  FindTextParams,
  FormatterStatus,
  FormatterStatusParams,
  LSPStatus,
  LspStatusParams,
  McpStatus200,
  McpStatusParams,
  NotFoundError,
  Path,
  PathGetParams,
  PostSessionIdPermissionsPermissionIDBody,
  PostSessionIdPermissionsPermissionIDParams,
  Project,
  ProjectCurrentParams,
  ProjectListParams,
  Session,
  SessionAbortParams,
  SessionChildrenParams,
  SessionCommand200,
  SessionCommandBody,
  SessionCommandParams,
  SessionCreateBody,
  SessionCreateParams,
  SessionDeleteParams,
  SessionDiffParams,
  SessionForkBody,
  SessionForkParams,
  SessionGetParams,
  SessionInitBody,
  SessionInitParams,
  SessionListParams,
  SessionMessage200,
  SessionMessageParams,
  SessionMessages200Item,
  SessionMessagesParams,
  SessionPrompt200,
  SessionPromptBody,
  SessionPromptParams,
  SessionRevertBody,
  SessionRevertParams,
  SessionShareParams,
  SessionShellBody,
  SessionShellParams,
  SessionSummarizeBody,
  SessionSummarizeParams,
  SessionTodoParams,
  SessionUnrevertParams,
  SessionUnshareParams,
  SessionUpdateBody,
  SessionUpdateParams,
  Symbol,
  Todo,
  ToolIDs,
  ToolIdsParams,
  ToolList,
  ToolListParams,
  TuiAppendPromptBody,
  TuiAppendPromptParams,
  TuiClearPromptParams,
  TuiControlNext200,
  TuiControlNextParams,
  TuiControlResponseParams,
  TuiExecuteCommandBody,
  TuiExecuteCommandParams,
  TuiOpenHelpParams,
  TuiOpenModelsParams,
  TuiOpenSessionsParams,
  TuiOpenThemesParams,
  TuiPublishBody,
  TuiPublishParams,
  TuiShowToastBody,
  TuiShowToastParams,
  TuiSubmitPromptParams,
} from '.././model'

import { customInstance } from '.././custom-instance'
import type { ErrorType, BodyType } from '.././custom-instance'

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1]

/**
 * List all projects
 */
export const projectList = (
  params?: ProjectListParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Project[]>(
    { url: `/project`, method: 'GET', params, signal },
    options,
  )
}

export const getProjectListQueryKey = (params?: ProjectListParams) => {
  return [`/project`, ...(params ? [params] : [])] as const
}

export const getProjectListQueryOptions = <
  TData = Awaited<ReturnType<typeof projectList>>,
  TError = ErrorType<unknown>,
>(
  params?: ProjectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof projectList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectList>>> = ({
    signal,
  }) => projectList(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectListQueryResult = NonNullable<
  Awaited<ReturnType<typeof projectList>>
>
export type ProjectListQueryError = ErrorType<unknown>

export function useProjectList<
  TData = Awaited<ReturnType<typeof projectList>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | ProjectListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof projectList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectList>>,
          TError,
          Awaited<ReturnType<typeof projectList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useProjectList<
  TData = Awaited<ReturnType<typeof projectList>>,
  TError = ErrorType<unknown>,
>(
  params?: ProjectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof projectList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectList>>,
          TError,
          Awaited<ReturnType<typeof projectList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useProjectList<
  TData = Awaited<ReturnType<typeof projectList>>,
  TError = ErrorType<unknown>,
>(
  params?: ProjectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof projectList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useProjectList<
  TData = Awaited<ReturnType<typeof projectList>>,
  TError = ErrorType<unknown>,
>(
  params?: ProjectListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof projectList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getProjectListQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get the current project
 */
export const projectCurrent = (
  params?: ProjectCurrentParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Project>(
    { url: `/project/current`, method: 'GET', params, signal },
    options,
  )
}

export const getProjectCurrentQueryKey = (params?: ProjectCurrentParams) => {
  return [`/project/current`, ...(params ? [params] : [])] as const
}

export const getProjectCurrentQueryOptions = <
  TData = Awaited<ReturnType<typeof projectCurrent>>,
  TError = ErrorType<unknown>,
>(
  params?: ProjectCurrentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof projectCurrent>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getProjectCurrentQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof projectCurrent>>> = ({
    signal,
  }) => projectCurrent(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof projectCurrent>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProjectCurrentQueryResult = NonNullable<
  Awaited<ReturnType<typeof projectCurrent>>
>
export type ProjectCurrentQueryError = ErrorType<unknown>

export function useProjectCurrent<
  TData = Awaited<ReturnType<typeof projectCurrent>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | ProjectCurrentParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof projectCurrent>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectCurrent>>,
          TError,
          Awaited<ReturnType<typeof projectCurrent>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useProjectCurrent<
  TData = Awaited<ReturnType<typeof projectCurrent>>,
  TError = ErrorType<unknown>,
>(
  params?: ProjectCurrentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof projectCurrent>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof projectCurrent>>,
          TError,
          Awaited<ReturnType<typeof projectCurrent>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useProjectCurrent<
  TData = Awaited<ReturnType<typeof projectCurrent>>,
  TError = ErrorType<unknown>,
>(
  params?: ProjectCurrentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof projectCurrent>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useProjectCurrent<
  TData = Awaited<ReturnType<typeof projectCurrent>>,
  TError = ErrorType<unknown>,
>(
  params?: ProjectCurrentParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof projectCurrent>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getProjectCurrentQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get config info
 */
export const configGet = (
  params?: ConfigGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Config>(
    { url: `/config`, method: 'GET', params, signal },
    options,
  )
}

export const getConfigGetQueryKey = (params?: ConfigGetParams) => {
  return [`/config`, ...(params ? [params] : [])] as const
}

export const getConfigGetQueryOptions = <
  TData = Awaited<ReturnType<typeof configGet>>,
  TError = ErrorType<unknown>,
>(
  params?: ConfigGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof configGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getConfigGetQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof configGet>>> = ({
    signal,
  }) => configGet(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof configGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ConfigGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof configGet>>
>
export type ConfigGetQueryError = ErrorType<unknown>

export function useConfigGet<
  TData = Awaited<ReturnType<typeof configGet>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | ConfigGetParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof configGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof configGet>>,
          TError,
          Awaited<ReturnType<typeof configGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useConfigGet<
  TData = Awaited<ReturnType<typeof configGet>>,
  TError = ErrorType<unknown>,
>(
  params?: ConfigGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof configGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof configGet>>,
          TError,
          Awaited<ReturnType<typeof configGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useConfigGet<
  TData = Awaited<ReturnType<typeof configGet>>,
  TError = ErrorType<unknown>,
>(
  params?: ConfigGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof configGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useConfigGet<
  TData = Awaited<ReturnType<typeof configGet>>,
  TError = ErrorType<unknown>,
>(
  params?: ConfigGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof configGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getConfigGetQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update config
 */
export const configUpdate = (
  config: BodyType<Config>,
  params?: ConfigUpdateParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Config>(
    {
      url: `/config`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: config,
      params,
    },
    options,
  )
}

export const getConfigUpdateMutationOptions = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof configUpdate>>,
    TError,
    { data: BodyType<Config>; params?: ConfigUpdateParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof configUpdate>>,
  TError,
  { data: BodyType<Config>; params?: ConfigUpdateParams },
  TContext
> => {
  const mutationKey = ['configUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof configUpdate>>,
    { data: BodyType<Config>; params?: ConfigUpdateParams }
  > = (props) => {
    const { data, params } = props ?? {}

    return configUpdate(data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ConfigUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof configUpdate>>
>
export type ConfigUpdateMutationBody = BodyType<Config>
export type ConfigUpdateMutationError = ErrorType<BadRequestError>

export const useConfigUpdate = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof configUpdate>>,
      TError,
      { data: BodyType<Config>; params?: ConfigUpdateParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof configUpdate>>,
  TError,
  { data: BodyType<Config>; params?: ConfigUpdateParams },
  TContext
> => {
  const mutationOptions = getConfigUpdateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * List all tool IDs (including built-in and dynamically registered)
 */
export const toolIds = (
  params?: ToolIdsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ToolIDs>(
    { url: `/experimental/tool/ids`, method: 'GET', params, signal },
    options,
  )
}

export const getToolIdsQueryKey = (params?: ToolIdsParams) => {
  return [`/experimental/tool/ids`, ...(params ? [params] : [])] as const
}

export const getToolIdsQueryOptions = <
  TData = Awaited<ReturnType<typeof toolIds>>,
  TError = ErrorType<BadRequestError>,
>(
  params?: ToolIdsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof toolIds>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getToolIdsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof toolIds>>> = ({
    signal,
  }) => toolIds(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof toolIds>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ToolIdsQueryResult = NonNullable<
  Awaited<ReturnType<typeof toolIds>>
>
export type ToolIdsQueryError = ErrorType<BadRequestError>

export function useToolIds<
  TData = Awaited<ReturnType<typeof toolIds>>,
  TError = ErrorType<BadRequestError>,
>(
  params: undefined | ToolIdsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof toolIds>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolIds>>,
          TError,
          Awaited<ReturnType<typeof toolIds>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useToolIds<
  TData = Awaited<ReturnType<typeof toolIds>>,
  TError = ErrorType<BadRequestError>,
>(
  params?: ToolIdsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof toolIds>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolIds>>,
          TError,
          Awaited<ReturnType<typeof toolIds>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useToolIds<
  TData = Awaited<ReturnType<typeof toolIds>>,
  TError = ErrorType<BadRequestError>,
>(
  params?: ToolIdsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof toolIds>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useToolIds<
  TData = Awaited<ReturnType<typeof toolIds>>,
  TError = ErrorType<BadRequestError>,
>(
  params?: ToolIdsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof toolIds>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getToolIdsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * List tools with JSON schema parameters for a provider/model
 */
export const toolList = (
  params: ToolListParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ToolList>(
    { url: `/experimental/tool`, method: 'GET', params, signal },
    options,
  )
}

export const getToolListQueryKey = (params?: ToolListParams) => {
  return [`/experimental/tool`, ...(params ? [params] : [])] as const
}

export const getToolListQueryOptions = <
  TData = Awaited<ReturnType<typeof toolList>>,
  TError = ErrorType<BadRequestError>,
>(
  params: ToolListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof toolList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getToolListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof toolList>>> = ({
    signal,
  }) => toolList(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof toolList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ToolListQueryResult = NonNullable<
  Awaited<ReturnType<typeof toolList>>
>
export type ToolListQueryError = ErrorType<BadRequestError>

export function useToolList<
  TData = Awaited<ReturnType<typeof toolList>>,
  TError = ErrorType<BadRequestError>,
>(
  params: ToolListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof toolList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolList>>,
          TError,
          Awaited<ReturnType<typeof toolList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useToolList<
  TData = Awaited<ReturnType<typeof toolList>>,
  TError = ErrorType<BadRequestError>,
>(
  params: ToolListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof toolList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof toolList>>,
          TError,
          Awaited<ReturnType<typeof toolList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useToolList<
  TData = Awaited<ReturnType<typeof toolList>>,
  TError = ErrorType<BadRequestError>,
>(
  params: ToolListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof toolList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useToolList<
  TData = Awaited<ReturnType<typeof toolList>>,
  TError = ErrorType<BadRequestError>,
>(
  params: ToolListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof toolList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getToolListQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get the current path
 */
export const pathGet = (
  params?: PathGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Path>(
    { url: `/path`, method: 'GET', params, signal },
    options,
  )
}

export const getPathGetQueryKey = (params?: PathGetParams) => {
  return [`/path`, ...(params ? [params] : [])] as const
}

export const getPathGetQueryOptions = <
  TData = Awaited<ReturnType<typeof pathGet>>,
  TError = ErrorType<unknown>,
>(
  params?: PathGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pathGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getPathGetQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof pathGet>>> = ({
    signal,
  }) => pathGet(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof pathGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PathGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof pathGet>>
>
export type PathGetQueryError = ErrorType<unknown>

export function usePathGet<
  TData = Awaited<ReturnType<typeof pathGet>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | PathGetParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pathGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof pathGet>>,
          TError,
          Awaited<ReturnType<typeof pathGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function usePathGet<
  TData = Awaited<ReturnType<typeof pathGet>>,
  TError = ErrorType<unknown>,
>(
  params?: PathGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pathGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof pathGet>>,
          TError,
          Awaited<ReturnType<typeof pathGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function usePathGet<
  TData = Awaited<ReturnType<typeof pathGet>>,
  TError = ErrorType<unknown>,
>(
  params?: PathGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pathGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function usePathGet<
  TData = Awaited<ReturnType<typeof pathGet>>,
  TError = ErrorType<unknown>,
>(
  params?: PathGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof pathGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getPathGetQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * List all sessions
 */
export const sessionList = (
  params?: SessionListParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Session[]>(
    { url: `/session`, method: 'GET', params, signal },
    options,
  )
}

export const getSessionListQueryKey = (params?: SessionListParams) => {
  return [`/session`, ...(params ? [params] : [])] as const
}

export const getSessionListQueryOptions = <
  TData = Awaited<ReturnType<typeof sessionList>>,
  TError = ErrorType<unknown>,
>(
  params?: SessionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSessionListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionList>>> = ({
    signal,
  }) => sessionList(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof sessionList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SessionListQueryResult = NonNullable<
  Awaited<ReturnType<typeof sessionList>>
>
export type SessionListQueryError = ErrorType<unknown>

export function useSessionList<
  TData = Awaited<ReturnType<typeof sessionList>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | SessionListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionList>>,
          TError,
          Awaited<ReturnType<typeof sessionList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionList<
  TData = Awaited<ReturnType<typeof sessionList>>,
  TError = ErrorType<unknown>,
>(
  params?: SessionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionList>>,
          TError,
          Awaited<ReturnType<typeof sessionList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionList<
  TData = Awaited<ReturnType<typeof sessionList>>,
  TError = ErrorType<unknown>,
>(
  params?: SessionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useSessionList<
  TData = Awaited<ReturnType<typeof sessionList>>,
  TError = ErrorType<unknown>,
>(
  params?: SessionListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getSessionListQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new session
 */
export const sessionCreate = (
  sessionCreateBody: BodyType<SessionCreateBody>,
  params?: SessionCreateParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Session>(
    {
      url: `/session`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: sessionCreateBody,
      params,
      signal,
    },
    options,
  )
}

export const getSessionCreateMutationOptions = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionCreate>>,
    TError,
    { data: BodyType<SessionCreateBody>; params?: SessionCreateParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionCreate>>,
  TError,
  { data: BodyType<SessionCreateBody>; params?: SessionCreateParams },
  TContext
> => {
  const mutationKey = ['sessionCreate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionCreate>>,
    { data: BodyType<SessionCreateBody>; params?: SessionCreateParams }
  > = (props) => {
    const { data, params } = props ?? {}

    return sessionCreate(data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionCreate>>
>
export type SessionCreateMutationBody = BodyType<SessionCreateBody>
export type SessionCreateMutationError = ErrorType<BadRequestError>

export const useSessionCreate = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionCreate>>,
      TError,
      { data: BodyType<SessionCreateBody>; params?: SessionCreateParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionCreate>>,
  TError,
  { data: BodyType<SessionCreateBody>; params?: SessionCreateParams },
  TContext
> => {
  const mutationOptions = getSessionCreateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get session
 */
export const sessionGet = (
  id: string,
  params?: SessionGetParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Session>(
    { url: `/session/${id}`, method: 'GET', params, signal },
    options,
  )
}

export const getSessionGetQueryKey = (
  id?: string,
  params?: SessionGetParams,
) => {
  return [`/session/${id}`, ...(params ? [params] : [])] as const
}

export const getSessionGetQueryOptions = <
  TData = Awaited<ReturnType<typeof sessionGet>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSessionGetQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionGet>>> = ({
    signal,
  }) => sessionGet(id, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof sessionGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SessionGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof sessionGet>>
>
export type SessionGetQueryError = ErrorType<BadRequestError | NotFoundError>

export function useSessionGet<
  TData = Awaited<ReturnType<typeof sessionGet>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params: undefined | SessionGetParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionGet>>,
          TError,
          Awaited<ReturnType<typeof sessionGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionGet<
  TData = Awaited<ReturnType<typeof sessionGet>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionGet>>,
          TError,
          Awaited<ReturnType<typeof sessionGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionGet<
  TData = Awaited<ReturnType<typeof sessionGet>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useSessionGet<
  TData = Awaited<ReturnType<typeof sessionGet>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionGet>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getSessionGetQueryOptions(id, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Delete a session and all its data
 */
export const sessionDelete = (
  id: string,
  params?: SessionDeleteParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<boolean>(
    { url: `/session/${id}`, method: 'DELETE', params },
    options,
  )
}

export const getSessionDeleteMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionDelete>>,
    TError,
    { id: string; params?: SessionDeleteParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionDelete>>,
  TError,
  { id: string; params?: SessionDeleteParams },
  TContext
> => {
  const mutationKey = ['sessionDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionDelete>>,
    { id: string; params?: SessionDeleteParams }
  > = (props) => {
    const { id, params } = props ?? {}

    return sessionDelete(id, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionDelete>>
>

export type SessionDeleteMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionDelete = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionDelete>>,
      TError,
      { id: string; params?: SessionDeleteParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionDelete>>,
  TError,
  { id: string; params?: SessionDeleteParams },
  TContext
> => {
  const mutationOptions = getSessionDeleteMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Update session properties
 */
export const sessionUpdate = (
  id: string,
  sessionUpdateBody: BodyType<SessionUpdateBody>,
  params?: SessionUpdateParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Session>(
    {
      url: `/session/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: sessionUpdateBody,
      params,
    },
    options,
  )
}

export const getSessionUpdateMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionUpdate>>,
    TError,
    {
      id: string
      data: BodyType<SessionUpdateBody>
      params?: SessionUpdateParams
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionUpdate>>,
  TError,
  {
    id: string
    data: BodyType<SessionUpdateBody>
    params?: SessionUpdateParams
  },
  TContext
> => {
  const mutationKey = ['sessionUpdate']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionUpdate>>,
    {
      id: string
      data: BodyType<SessionUpdateBody>
      params?: SessionUpdateParams
    }
  > = (props) => {
    const { id, data, params } = props ?? {}

    return sessionUpdate(id, data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionUpdate>>
>
export type SessionUpdateMutationBody = BodyType<SessionUpdateBody>
export type SessionUpdateMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionUpdate = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionUpdate>>,
      TError,
      {
        id: string
        data: BodyType<SessionUpdateBody>
        params?: SessionUpdateParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionUpdate>>,
  TError,
  {
    id: string
    data: BodyType<SessionUpdateBody>
    params?: SessionUpdateParams
  },
  TContext
> => {
  const mutationOptions = getSessionUpdateMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get a session's children
 */
export const sessionChildren = (
  id: string,
  params?: SessionChildrenParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Session[]>(
    { url: `/session/${id}/children`, method: 'GET', params, signal },
    options,
  )
}

export const getSessionChildrenQueryKey = (
  id?: string,
  params?: SessionChildrenParams,
) => {
  return [`/session/${id}/children`, ...(params ? [params] : [])] as const
}

export const getSessionChildrenQueryOptions = <
  TData = Awaited<ReturnType<typeof sessionChildren>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionChildrenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sessionChildren>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getSessionChildrenQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionChildren>>> = ({
    signal,
  }) => sessionChildren(id, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof sessionChildren>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SessionChildrenQueryResult = NonNullable<
  Awaited<ReturnType<typeof sessionChildren>>
>
export type SessionChildrenQueryError = ErrorType<
  BadRequestError | NotFoundError
>

export function useSessionChildren<
  TData = Awaited<ReturnType<typeof sessionChildren>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params: undefined | SessionChildrenParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sessionChildren>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionChildren>>,
          TError,
          Awaited<ReturnType<typeof sessionChildren>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionChildren<
  TData = Awaited<ReturnType<typeof sessionChildren>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionChildrenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sessionChildren>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionChildren>>,
          TError,
          Awaited<ReturnType<typeof sessionChildren>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionChildren<
  TData = Awaited<ReturnType<typeof sessionChildren>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionChildrenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sessionChildren>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useSessionChildren<
  TData = Awaited<ReturnType<typeof sessionChildren>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionChildrenParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sessionChildren>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getSessionChildrenQueryOptions(id, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get the todo list for a session
 */
export const sessionTodo = (
  id: string,
  params?: SessionTodoParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Todo[]>(
    { url: `/session/${id}/todo`, method: 'GET', params, signal },
    options,
  )
}

export const getSessionTodoQueryKey = (
  id?: string,
  params?: SessionTodoParams,
) => {
  return [`/session/${id}/todo`, ...(params ? [params] : [])] as const
}

export const getSessionTodoQueryOptions = <
  TData = Awaited<ReturnType<typeof sessionTodo>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionTodoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionTodo>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSessionTodoQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionTodo>>> = ({
    signal,
  }) => sessionTodo(id, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof sessionTodo>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SessionTodoQueryResult = NonNullable<
  Awaited<ReturnType<typeof sessionTodo>>
>
export type SessionTodoQueryError = ErrorType<BadRequestError | NotFoundError>

export function useSessionTodo<
  TData = Awaited<ReturnType<typeof sessionTodo>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params: undefined | SessionTodoParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionTodo>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionTodo>>,
          TError,
          Awaited<ReturnType<typeof sessionTodo>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionTodo<
  TData = Awaited<ReturnType<typeof sessionTodo>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionTodoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionTodo>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionTodo>>,
          TError,
          Awaited<ReturnType<typeof sessionTodo>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionTodo<
  TData = Awaited<ReturnType<typeof sessionTodo>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionTodoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionTodo>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useSessionTodo<
  TData = Awaited<ReturnType<typeof sessionTodo>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionTodoParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionTodo>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getSessionTodoQueryOptions(id, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Analyze the app and create an AGENTS.md file
 */
export const sessionInit = (
  id: string,
  sessionInitBody: BodyType<SessionInitBody>,
  params?: SessionInitParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `/session/${id}/init`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: sessionInitBody,
      params,
      signal,
    },
    options,
  )
}

export const getSessionInitMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionInit>>,
    TError,
    { id: string; data: BodyType<SessionInitBody>; params?: SessionInitParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionInit>>,
  TError,
  { id: string; data: BodyType<SessionInitBody>; params?: SessionInitParams },
  TContext
> => {
  const mutationKey = ['sessionInit']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionInit>>,
    { id: string; data: BodyType<SessionInitBody>; params?: SessionInitParams }
  > = (props) => {
    const { id, data, params } = props ?? {}

    return sessionInit(id, data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionInitMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionInit>>
>
export type SessionInitMutationBody = BodyType<SessionInitBody>
export type SessionInitMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionInit = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionInit>>,
      TError,
      {
        id: string
        data: BodyType<SessionInitBody>
        params?: SessionInitParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionInit>>,
  TError,
  { id: string; data: BodyType<SessionInitBody>; params?: SessionInitParams },
  TContext
> => {
  const mutationOptions = getSessionInitMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Fork an existing session at a specific message
 */
export const sessionFork = (
  id: string,
  sessionForkBody: BodyType<SessionForkBody>,
  params?: SessionForkParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Session>(
    {
      url: `/session/${id}/fork`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: sessionForkBody,
      params,
      signal,
    },
    options,
  )
}

export const getSessionForkMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionFork>>,
    TError,
    { id: string; data: BodyType<SessionForkBody>; params?: SessionForkParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionFork>>,
  TError,
  { id: string; data: BodyType<SessionForkBody>; params?: SessionForkParams },
  TContext
> => {
  const mutationKey = ['sessionFork']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionFork>>,
    { id: string; data: BodyType<SessionForkBody>; params?: SessionForkParams }
  > = (props) => {
    const { id, data, params } = props ?? {}

    return sessionFork(id, data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionForkMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionFork>>
>
export type SessionForkMutationBody = BodyType<SessionForkBody>
export type SessionForkMutationError = ErrorType<unknown>

export const useSessionFork = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionFork>>,
      TError,
      {
        id: string
        data: BodyType<SessionForkBody>
        params?: SessionForkParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionFork>>,
  TError,
  { id: string; data: BodyType<SessionForkBody>; params?: SessionForkParams },
  TContext
> => {
  const mutationOptions = getSessionForkMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Abort a session
 */
export const sessionAbort = (
  id: string,
  params?: SessionAbortParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/session/${id}/abort`, method: 'POST', params, signal },
    options,
  )
}

export const getSessionAbortMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionAbort>>,
    TError,
    { id: string; params?: SessionAbortParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionAbort>>,
  TError,
  { id: string; params?: SessionAbortParams },
  TContext
> => {
  const mutationKey = ['sessionAbort']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionAbort>>,
    { id: string; params?: SessionAbortParams }
  > = (props) => {
    const { id, params } = props ?? {}

    return sessionAbort(id, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionAbortMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionAbort>>
>

export type SessionAbortMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionAbort = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionAbort>>,
      TError,
      { id: string; params?: SessionAbortParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionAbort>>,
  TError,
  { id: string; params?: SessionAbortParams },
  TContext
> => {
  const mutationOptions = getSessionAbortMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Share a session
 */
export const sessionShare = (
  id: string,
  params?: SessionShareParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Session>(
    { url: `/session/${id}/share`, method: 'POST', params, signal },
    options,
  )
}

export const getSessionShareMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionShare>>,
    TError,
    { id: string; params?: SessionShareParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionShare>>,
  TError,
  { id: string; params?: SessionShareParams },
  TContext
> => {
  const mutationKey = ['sessionShare']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionShare>>,
    { id: string; params?: SessionShareParams }
  > = (props) => {
    const { id, params } = props ?? {}

    return sessionShare(id, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionShareMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionShare>>
>

export type SessionShareMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionShare = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionShare>>,
      TError,
      { id: string; params?: SessionShareParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionShare>>,
  TError,
  { id: string; params?: SessionShareParams },
  TContext
> => {
  const mutationOptions = getSessionShareMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Unshare the session
 */
export const sessionUnshare = (
  id: string,
  params?: SessionUnshareParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Session>(
    { url: `/session/${id}/share`, method: 'DELETE', params },
    options,
  )
}

export const getSessionUnshareMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionUnshare>>,
    TError,
    { id: string; params?: SessionUnshareParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionUnshare>>,
  TError,
  { id: string; params?: SessionUnshareParams },
  TContext
> => {
  const mutationKey = ['sessionUnshare']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionUnshare>>,
    { id: string; params?: SessionUnshareParams }
  > = (props) => {
    const { id, params } = props ?? {}

    return sessionUnshare(id, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionUnshareMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionUnshare>>
>

export type SessionUnshareMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionUnshare = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionUnshare>>,
      TError,
      { id: string; params?: SessionUnshareParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionUnshare>>,
  TError,
  { id: string; params?: SessionUnshareParams },
  TContext
> => {
  const mutationOptions = getSessionUnshareMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get the diff that resulted from this user message
 */
export const sessionDiff = (
  id: string,
  params?: SessionDiffParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<FileDiff[]>(
    { url: `/session/${id}/diff`, method: 'GET', params, signal },
    options,
  )
}

export const getSessionDiffQueryKey = (
  id?: string,
  params?: SessionDiffParams,
) => {
  return [`/session/${id}/diff`, ...(params ? [params] : [])] as const
}

export const getSessionDiffQueryOptions = <
  TData = Awaited<ReturnType<typeof sessionDiff>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params?: SessionDiffParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionDiff>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getSessionDiffQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionDiff>>> = ({
    signal,
  }) => sessionDiff(id, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof sessionDiff>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SessionDiffQueryResult = NonNullable<
  Awaited<ReturnType<typeof sessionDiff>>
>
export type SessionDiffQueryError = ErrorType<unknown>

export function useSessionDiff<
  TData = Awaited<ReturnType<typeof sessionDiff>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params: undefined | SessionDiffParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionDiff>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionDiff>>,
          TError,
          Awaited<ReturnType<typeof sessionDiff>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionDiff<
  TData = Awaited<ReturnType<typeof sessionDiff>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params?: SessionDiffParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionDiff>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionDiff>>,
          TError,
          Awaited<ReturnType<typeof sessionDiff>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionDiff<
  TData = Awaited<ReturnType<typeof sessionDiff>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params?: SessionDiffParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionDiff>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useSessionDiff<
  TData = Awaited<ReturnType<typeof sessionDiff>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  params?: SessionDiffParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionDiff>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getSessionDiffQueryOptions(id, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Summarize the session
 */
export const sessionSummarize = (
  id: string,
  sessionSummarizeBody: BodyType<SessionSummarizeBody>,
  params?: SessionSummarizeParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `/session/${id}/summarize`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: sessionSummarizeBody,
      params,
      signal,
    },
    options,
  )
}

export const getSessionSummarizeMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionSummarize>>,
    TError,
    {
      id: string
      data: BodyType<SessionSummarizeBody>
      params?: SessionSummarizeParams
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionSummarize>>,
  TError,
  {
    id: string
    data: BodyType<SessionSummarizeBody>
    params?: SessionSummarizeParams
  },
  TContext
> => {
  const mutationKey = ['sessionSummarize']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionSummarize>>,
    {
      id: string
      data: BodyType<SessionSummarizeBody>
      params?: SessionSummarizeParams
    }
  > = (props) => {
    const { id, data, params } = props ?? {}

    return sessionSummarize(id, data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionSummarizeMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionSummarize>>
>
export type SessionSummarizeMutationBody = BodyType<SessionSummarizeBody>
export type SessionSummarizeMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionSummarize = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionSummarize>>,
      TError,
      {
        id: string
        data: BodyType<SessionSummarizeBody>
        params?: SessionSummarizeParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionSummarize>>,
  TError,
  {
    id: string
    data: BodyType<SessionSummarizeBody>
    params?: SessionSummarizeParams
  },
  TContext
> => {
  const mutationOptions = getSessionSummarizeMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * List messages for a session
 */
export const sessionMessages = (
  id: string,
  params?: SessionMessagesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SessionMessages200Item[]>(
    { url: `/session/${id}/message`, method: 'GET', params, signal },
    options,
  )
}

export const getSessionMessagesQueryKey = (
  id?: string,
  params?: SessionMessagesParams,
) => {
  return [`/session/${id}/message`, ...(params ? [params] : [])] as const
}

export const getSessionMessagesQueryOptions = <
  TData = Awaited<ReturnType<typeof sessionMessages>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionMessagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sessionMessages>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getSessionMessagesQueryKey(id, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionMessages>>> = ({
    signal,
  }) => sessionMessages(id, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof sessionMessages>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SessionMessagesQueryResult = NonNullable<
  Awaited<ReturnType<typeof sessionMessages>>
>
export type SessionMessagesQueryError = ErrorType<
  BadRequestError | NotFoundError
>

export function useSessionMessages<
  TData = Awaited<ReturnType<typeof sessionMessages>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params: undefined | SessionMessagesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sessionMessages>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionMessages>>,
          TError,
          Awaited<ReturnType<typeof sessionMessages>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionMessages<
  TData = Awaited<ReturnType<typeof sessionMessages>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionMessagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sessionMessages>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionMessages>>,
          TError,
          Awaited<ReturnType<typeof sessionMessages>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionMessages<
  TData = Awaited<ReturnType<typeof sessionMessages>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionMessagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sessionMessages>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useSessionMessages<
  TData = Awaited<ReturnType<typeof sessionMessages>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  params?: SessionMessagesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sessionMessages>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getSessionMessagesQueryOptions(id, params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create and send a new message to a session
 */
export const sessionPrompt = (
  id: string,
  sessionPromptBody: BodyType<SessionPromptBody>,
  params?: SessionPromptParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SessionPrompt200>(
    {
      url: `/session/${id}/message`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: sessionPromptBody,
      params,
      signal,
    },
    options,
  )
}

export const getSessionPromptMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionPrompt>>,
    TError,
    {
      id: string
      data: BodyType<SessionPromptBody>
      params?: SessionPromptParams
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionPrompt>>,
  TError,
  {
    id: string
    data: BodyType<SessionPromptBody>
    params?: SessionPromptParams
  },
  TContext
> => {
  const mutationKey = ['sessionPrompt']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionPrompt>>,
    {
      id: string
      data: BodyType<SessionPromptBody>
      params?: SessionPromptParams
    }
  > = (props) => {
    const { id, data, params } = props ?? {}

    return sessionPrompt(id, data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionPromptMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionPrompt>>
>
export type SessionPromptMutationBody = BodyType<SessionPromptBody>
export type SessionPromptMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionPrompt = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionPrompt>>,
      TError,
      {
        id: string
        data: BodyType<SessionPromptBody>
        params?: SessionPromptParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionPrompt>>,
  TError,
  {
    id: string
    data: BodyType<SessionPromptBody>
    params?: SessionPromptParams
  },
  TContext
> => {
  const mutationOptions = getSessionPromptMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get a message from a session
 */
export const sessionMessage = (
  id: string,
  messageID: string,
  params?: SessionMessageParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SessionMessage200>(
    {
      url: `/session/${id}/message/${messageID}`,
      method: 'GET',
      params,
      signal,
    },
    options,
  )
}

export const getSessionMessageQueryKey = (
  id?: string,
  messageID?: string,
  params?: SessionMessageParams,
) => {
  return [
    `/session/${id}/message/${messageID}`,
    ...(params ? [params] : []),
  ] as const
}

export const getSessionMessageQueryOptions = <
  TData = Awaited<ReturnType<typeof sessionMessage>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  messageID: string,
  params?: SessionMessageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionMessage>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getSessionMessageQueryKey(id, messageID, params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sessionMessage>>> = ({
    signal,
  }) => sessionMessage(id, messageID, params, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!(id && messageID),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof sessionMessage>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SessionMessageQueryResult = NonNullable<
  Awaited<ReturnType<typeof sessionMessage>>
>
export type SessionMessageQueryError = ErrorType<
  BadRequestError | NotFoundError
>

export function useSessionMessage<
  TData = Awaited<ReturnType<typeof sessionMessage>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  messageID: string,
  params: undefined | SessionMessageParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionMessage>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionMessage>>,
          TError,
          Awaited<ReturnType<typeof sessionMessage>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionMessage<
  TData = Awaited<ReturnType<typeof sessionMessage>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  messageID: string,
  params?: SessionMessageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionMessage>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sessionMessage>>,
          TError,
          Awaited<ReturnType<typeof sessionMessage>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useSessionMessage<
  TData = Awaited<ReturnType<typeof sessionMessage>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  messageID: string,
  params?: SessionMessageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionMessage>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useSessionMessage<
  TData = Awaited<ReturnType<typeof sessionMessage>>,
  TError = ErrorType<BadRequestError | NotFoundError>,
>(
  id: string,
  messageID: string,
  params?: SessionMessageParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sessionMessage>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getSessionMessageQueryOptions(
    id,
    messageID,
    params,
    options,
  )

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Send a new command to a session
 */
export const sessionCommand = (
  id: string,
  sessionCommandBody: BodyType<SessionCommandBody>,
  params?: SessionCommandParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SessionCommand200>(
    {
      url: `/session/${id}/command`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: sessionCommandBody,
      params,
      signal,
    },
    options,
  )
}

export const getSessionCommandMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionCommand>>,
    TError,
    {
      id: string
      data: BodyType<SessionCommandBody>
      params?: SessionCommandParams
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionCommand>>,
  TError,
  {
    id: string
    data: BodyType<SessionCommandBody>
    params?: SessionCommandParams
  },
  TContext
> => {
  const mutationKey = ['sessionCommand']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionCommand>>,
    {
      id: string
      data: BodyType<SessionCommandBody>
      params?: SessionCommandParams
    }
  > = (props) => {
    const { id, data, params } = props ?? {}

    return sessionCommand(id, data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionCommandMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionCommand>>
>
export type SessionCommandMutationBody = BodyType<SessionCommandBody>
export type SessionCommandMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionCommand = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionCommand>>,
      TError,
      {
        id: string
        data: BodyType<SessionCommandBody>
        params?: SessionCommandParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionCommand>>,
  TError,
  {
    id: string
    data: BodyType<SessionCommandBody>
    params?: SessionCommandParams
  },
  TContext
> => {
  const mutationOptions = getSessionCommandMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Run a shell command
 */
export const sessionShell = (
  id: string,
  sessionShellBody: BodyType<SessionShellBody>,
  params?: SessionShellParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AssistantMessage>(
    {
      url: `/session/${id}/shell`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: sessionShellBody,
      params,
      signal,
    },
    options,
  )
}

export const getSessionShellMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionShell>>,
    TError,
    {
      id: string
      data: BodyType<SessionShellBody>
      params?: SessionShellParams
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionShell>>,
  TError,
  { id: string; data: BodyType<SessionShellBody>; params?: SessionShellParams },
  TContext
> => {
  const mutationKey = ['sessionShell']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionShell>>,
    {
      id: string
      data: BodyType<SessionShellBody>
      params?: SessionShellParams
    }
  > = (props) => {
    const { id, data, params } = props ?? {}

    return sessionShell(id, data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionShellMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionShell>>
>
export type SessionShellMutationBody = BodyType<SessionShellBody>
export type SessionShellMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionShell = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionShell>>,
      TError,
      {
        id: string
        data: BodyType<SessionShellBody>
        params?: SessionShellParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionShell>>,
  TError,
  { id: string; data: BodyType<SessionShellBody>; params?: SessionShellParams },
  TContext
> => {
  const mutationOptions = getSessionShellMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Revert a message
 */
export const sessionRevert = (
  id: string,
  sessionRevertBody: BodyType<SessionRevertBody>,
  params?: SessionRevertParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Session>(
    {
      url: `/session/${id}/revert`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: sessionRevertBody,
      params,
      signal,
    },
    options,
  )
}

export const getSessionRevertMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionRevert>>,
    TError,
    {
      id: string
      data: BodyType<SessionRevertBody>
      params?: SessionRevertParams
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionRevert>>,
  TError,
  {
    id: string
    data: BodyType<SessionRevertBody>
    params?: SessionRevertParams
  },
  TContext
> => {
  const mutationKey = ['sessionRevert']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionRevert>>,
    {
      id: string
      data: BodyType<SessionRevertBody>
      params?: SessionRevertParams
    }
  > = (props) => {
    const { id, data, params } = props ?? {}

    return sessionRevert(id, data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionRevertMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionRevert>>
>
export type SessionRevertMutationBody = BodyType<SessionRevertBody>
export type SessionRevertMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionRevert = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionRevert>>,
      TError,
      {
        id: string
        data: BodyType<SessionRevertBody>
        params?: SessionRevertParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionRevert>>,
  TError,
  {
    id: string
    data: BodyType<SessionRevertBody>
    params?: SessionRevertParams
  },
  TContext
> => {
  const mutationOptions = getSessionRevertMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Restore all reverted messages
 */
export const sessionUnrevert = (
  id: string,
  params?: SessionUnrevertParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Session>(
    { url: `/session/${id}/unrevert`, method: 'POST', params, signal },
    options,
  )
}

export const getSessionUnrevertMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sessionUnrevert>>,
    TError,
    { id: string; params?: SessionUnrevertParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof sessionUnrevert>>,
  TError,
  { id: string; params?: SessionUnrevertParams },
  TContext
> => {
  const mutationKey = ['sessionUnrevert']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sessionUnrevert>>,
    { id: string; params?: SessionUnrevertParams }
  > = (props) => {
    const { id, params } = props ?? {}

    return sessionUnrevert(id, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type SessionUnrevertMutationResult = NonNullable<
  Awaited<ReturnType<typeof sessionUnrevert>>
>

export type SessionUnrevertMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const useSessionUnrevert = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sessionUnrevert>>,
      TError,
      { id: string; params?: SessionUnrevertParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sessionUnrevert>>,
  TError,
  { id: string; params?: SessionUnrevertParams },
  TContext
> => {
  const mutationOptions = getSessionUnrevertMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Respond to a permission request
 */
export const postSessionIdPermissionsPermissionID = (
  id: string,
  permissionID: string,
  postSessionIdPermissionsPermissionIDBody: BodyType<PostSessionIdPermissionsPermissionIDBody>,
  params?: PostSessionIdPermissionsPermissionIDParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `/session/${id}/permissions/${permissionID}`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: postSessionIdPermissionsPermissionIDBody,
      params,
      signal,
    },
    options,
  )
}

export const getPostSessionIdPermissionsPermissionIDMutationOptions = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postSessionIdPermissionsPermissionID>>,
    TError,
    {
      id: string
      permissionID: string
      data: BodyType<PostSessionIdPermissionsPermissionIDBody>
      params?: PostSessionIdPermissionsPermissionIDParams
    },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postSessionIdPermissionsPermissionID>>,
  TError,
  {
    id: string
    permissionID: string
    data: BodyType<PostSessionIdPermissionsPermissionIDBody>
    params?: PostSessionIdPermissionsPermissionIDParams
  },
  TContext
> => {
  const mutationKey = ['postSessionIdPermissionsPermissionID']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postSessionIdPermissionsPermissionID>>,
    {
      id: string
      permissionID: string
      data: BodyType<PostSessionIdPermissionsPermissionIDBody>
      params?: PostSessionIdPermissionsPermissionIDParams
    }
  > = (props) => {
    const { id, permissionID, data, params } = props ?? {}

    return postSessionIdPermissionsPermissionID(
      id,
      permissionID,
      data,
      params,
      requestOptions,
    )
  }

  return { mutationFn, ...mutationOptions }
}

export type PostSessionIdPermissionsPermissionIDMutationResult = NonNullable<
  Awaited<ReturnType<typeof postSessionIdPermissionsPermissionID>>
>
export type PostSessionIdPermissionsPermissionIDMutationBody =
  BodyType<PostSessionIdPermissionsPermissionIDBody>
export type PostSessionIdPermissionsPermissionIDMutationError = ErrorType<
  BadRequestError | NotFoundError
>

export const usePostSessionIdPermissionsPermissionID = <
  TError = ErrorType<BadRequestError | NotFoundError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postSessionIdPermissionsPermissionID>>,
      TError,
      {
        id: string
        permissionID: string
        data: BodyType<PostSessionIdPermissionsPermissionIDBody>
        params?: PostSessionIdPermissionsPermissionIDParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postSessionIdPermissionsPermissionID>>,
  TError,
  {
    id: string
    permissionID: string
    data: BodyType<PostSessionIdPermissionsPermissionIDBody>
    params?: PostSessionIdPermissionsPermissionIDParams
  },
  TContext
> => {
  const mutationOptions =
    getPostSessionIdPermissionsPermissionIDMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * List all commands
 */
export const commandList = (
  params?: CommandListParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Command[]>(
    { url: `/command`, method: 'GET', params, signal },
    options,
  )
}

export const getCommandListQueryKey = (params?: CommandListParams) => {
  return [`/command`, ...(params ? [params] : [])] as const
}

export const getCommandListQueryOptions = <
  TData = Awaited<ReturnType<typeof commandList>>,
  TError = ErrorType<unknown>,
>(
  params?: CommandListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof commandList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getCommandListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof commandList>>> = ({
    signal,
  }) => commandList(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof commandList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CommandListQueryResult = NonNullable<
  Awaited<ReturnType<typeof commandList>>
>
export type CommandListQueryError = ErrorType<unknown>

export function useCommandList<
  TData = Awaited<ReturnType<typeof commandList>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | CommandListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof commandList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof commandList>>,
          TError,
          Awaited<ReturnType<typeof commandList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCommandList<
  TData = Awaited<ReturnType<typeof commandList>>,
  TError = ErrorType<unknown>,
>(
  params?: CommandListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof commandList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof commandList>>,
          TError,
          Awaited<ReturnType<typeof commandList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useCommandList<
  TData = Awaited<ReturnType<typeof commandList>>,
  TError = ErrorType<unknown>,
>(
  params?: CommandListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof commandList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useCommandList<
  TData = Awaited<ReturnType<typeof commandList>>,
  TError = ErrorType<unknown>,
>(
  params?: CommandListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof commandList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getCommandListQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * List all providers
 */
export const configProviders = (
  params?: ConfigProvidersParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ConfigProviders200>(
    { url: `/config/providers`, method: 'GET', params, signal },
    options,
  )
}

export const getConfigProvidersQueryKey = (params?: ConfigProvidersParams) => {
  return [`/config/providers`, ...(params ? [params] : [])] as const
}

export const getConfigProvidersQueryOptions = <
  TData = Awaited<ReturnType<typeof configProviders>>,
  TError = ErrorType<unknown>,
>(
  params?: ConfigProvidersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof configProviders>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getConfigProvidersQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof configProviders>>> = ({
    signal,
  }) => configProviders(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof configProviders>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ConfigProvidersQueryResult = NonNullable<
  Awaited<ReturnType<typeof configProviders>>
>
export type ConfigProvidersQueryError = ErrorType<unknown>

export function useConfigProviders<
  TData = Awaited<ReturnType<typeof configProviders>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | ConfigProvidersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof configProviders>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof configProviders>>,
          TError,
          Awaited<ReturnType<typeof configProviders>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useConfigProviders<
  TData = Awaited<ReturnType<typeof configProviders>>,
  TError = ErrorType<unknown>,
>(
  params?: ConfigProvidersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof configProviders>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof configProviders>>,
          TError,
          Awaited<ReturnType<typeof configProviders>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useConfigProviders<
  TData = Awaited<ReturnType<typeof configProviders>>,
  TError = ErrorType<unknown>,
>(
  params?: ConfigProvidersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof configProviders>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useConfigProviders<
  TData = Awaited<ReturnType<typeof configProviders>>,
  TError = ErrorType<unknown>,
>(
  params?: ConfigProvidersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof configProviders>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getConfigProvidersQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Find text in files
 */
export const findText = (
  params: FindTextParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<FindText200Item[]>(
    { url: `/find`, method: 'GET', params, signal },
    options,
  )
}

export const getFindTextQueryKey = (params?: FindTextParams) => {
  return [`/find`, ...(params ? [params] : [])] as const
}

export const getFindTextQueryOptions = <
  TData = Awaited<ReturnType<typeof findText>>,
  TError = ErrorType<unknown>,
>(
  params: FindTextParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findText>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindTextQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findText>>> = ({
    signal,
  }) => findText(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findText>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindTextQueryResult = NonNullable<
  Awaited<ReturnType<typeof findText>>
>
export type FindTextQueryError = ErrorType<unknown>

export function useFindText<
  TData = Awaited<ReturnType<typeof findText>>,
  TError = ErrorType<unknown>,
>(
  params: FindTextParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findText>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findText>>,
          TError,
          Awaited<ReturnType<typeof findText>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindText<
  TData = Awaited<ReturnType<typeof findText>>,
  TError = ErrorType<unknown>,
>(
  params: FindTextParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findText>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findText>>,
          TError,
          Awaited<ReturnType<typeof findText>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindText<
  TData = Awaited<ReturnType<typeof findText>>,
  TError = ErrorType<unknown>,
>(
  params: FindTextParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findText>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useFindText<
  TData = Awaited<ReturnType<typeof findText>>,
  TError = ErrorType<unknown>,
>(
  params: FindTextParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findText>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindTextQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Find files
 */
export const findFiles = (
  params: FindFilesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<string[]>(
    { url: `/find/file`, method: 'GET', params, signal },
    options,
  )
}

export const getFindFilesQueryKey = (params?: FindFilesParams) => {
  return [`/find/file`, ...(params ? [params] : [])] as const
}

export const getFindFilesQueryOptions = <
  TData = Awaited<ReturnType<typeof findFiles>>,
  TError = ErrorType<unknown>,
>(
  params: FindFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findFiles>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindFilesQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findFiles>>> = ({
    signal,
  }) => findFiles(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findFiles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindFilesQueryResult = NonNullable<
  Awaited<ReturnType<typeof findFiles>>
>
export type FindFilesQueryError = ErrorType<unknown>

export function useFindFiles<
  TData = Awaited<ReturnType<typeof findFiles>>,
  TError = ErrorType<unknown>,
>(
  params: FindFilesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findFiles>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findFiles>>,
          TError,
          Awaited<ReturnType<typeof findFiles>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindFiles<
  TData = Awaited<ReturnType<typeof findFiles>>,
  TError = ErrorType<unknown>,
>(
  params: FindFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findFiles>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findFiles>>,
          TError,
          Awaited<ReturnType<typeof findFiles>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindFiles<
  TData = Awaited<ReturnType<typeof findFiles>>,
  TError = ErrorType<unknown>,
>(
  params: FindFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findFiles>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useFindFiles<
  TData = Awaited<ReturnType<typeof findFiles>>,
  TError = ErrorType<unknown>,
>(
  params: FindFilesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findFiles>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindFilesQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Find workspace symbols
 */
export const findSymbols = (
  params: FindSymbolsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Symbol[]>(
    { url: `/find/symbol`, method: 'GET', params, signal },
    options,
  )
}

export const getFindSymbolsQueryKey = (params?: FindSymbolsParams) => {
  return [`/find/symbol`, ...(params ? [params] : [])] as const
}

export const getFindSymbolsQueryOptions = <
  TData = Awaited<ReturnType<typeof findSymbols>>,
  TError = ErrorType<unknown>,
>(
  params: FindSymbolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSymbols>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFindSymbolsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findSymbols>>> = ({
    signal,
  }) => findSymbols(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findSymbols>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FindSymbolsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findSymbols>>
>
export type FindSymbolsQueryError = ErrorType<unknown>

export function useFindSymbols<
  TData = Awaited<ReturnType<typeof findSymbols>>,
  TError = ErrorType<unknown>,
>(
  params: FindSymbolsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSymbols>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findSymbols>>,
          TError,
          Awaited<ReturnType<typeof findSymbols>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindSymbols<
  TData = Awaited<ReturnType<typeof findSymbols>>,
  TError = ErrorType<unknown>,
>(
  params: FindSymbolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSymbols>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findSymbols>>,
          TError,
          Awaited<ReturnType<typeof findSymbols>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFindSymbols<
  TData = Awaited<ReturnType<typeof findSymbols>>,
  TError = ErrorType<unknown>,
>(
  params: FindSymbolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSymbols>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useFindSymbols<
  TData = Awaited<ReturnType<typeof findSymbols>>,
  TError = ErrorType<unknown>,
>(
  params: FindSymbolsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findSymbols>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFindSymbolsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * List files and directories
 */
export const fileList = (
  params: FileListParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<FileNode[]>(
    { url: `/file`, method: 'GET', params, signal },
    options,
  )
}

export const getFileListQueryKey = (params?: FileListParams) => {
  return [`/file`, ...(params ? [params] : [])] as const
}

export const getFileListQueryOptions = <
  TData = Awaited<ReturnType<typeof fileList>>,
  TError = ErrorType<unknown>,
>(
  params: FileListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFileListQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof fileList>>> = ({
    signal,
  }) => fileList(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof fileList>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FileListQueryResult = NonNullable<
  Awaited<ReturnType<typeof fileList>>
>
export type FileListQueryError = ErrorType<unknown>

export function useFileList<
  TData = Awaited<ReturnType<typeof fileList>>,
  TError = ErrorType<unknown>,
>(
  params: FileListParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileList>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileList>>,
          TError,
          Awaited<ReturnType<typeof fileList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFileList<
  TData = Awaited<ReturnType<typeof fileList>>,
  TError = ErrorType<unknown>,
>(
  params: FileListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileList>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileList>>,
          TError,
          Awaited<ReturnType<typeof fileList>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFileList<
  TData = Awaited<ReturnType<typeof fileList>>,
  TError = ErrorType<unknown>,
>(
  params: FileListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useFileList<
  TData = Awaited<ReturnType<typeof fileList>>,
  TError = ErrorType<unknown>,
>(
  params: FileListParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileList>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFileListQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Read a file
 */
export const fileRead = (
  params: FileReadParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<FileContent>(
    { url: `/file/content`, method: 'GET', params, signal },
    options,
  )
}

export const getFileReadQueryKey = (params?: FileReadParams) => {
  return [`/file/content`, ...(params ? [params] : [])] as const
}

export const getFileReadQueryOptions = <
  TData = Awaited<ReturnType<typeof fileRead>>,
  TError = ErrorType<unknown>,
>(
  params: FileReadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileRead>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFileReadQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof fileRead>>> = ({
    signal,
  }) => fileRead(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof fileRead>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FileReadQueryResult = NonNullable<
  Awaited<ReturnType<typeof fileRead>>
>
export type FileReadQueryError = ErrorType<unknown>

export function useFileRead<
  TData = Awaited<ReturnType<typeof fileRead>>,
  TError = ErrorType<unknown>,
>(
  params: FileReadParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileRead>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileRead>>,
          TError,
          Awaited<ReturnType<typeof fileRead>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFileRead<
  TData = Awaited<ReturnType<typeof fileRead>>,
  TError = ErrorType<unknown>,
>(
  params: FileReadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileRead>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileRead>>,
          TError,
          Awaited<ReturnType<typeof fileRead>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFileRead<
  TData = Awaited<ReturnType<typeof fileRead>>,
  TError = ErrorType<unknown>,
>(
  params: FileReadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileRead>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useFileRead<
  TData = Awaited<ReturnType<typeof fileRead>>,
  TError = ErrorType<unknown>,
>(
  params: FileReadParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileRead>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFileReadQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get file status
 */
export const fileStatus = (
  params?: FileStatusParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<File[]>(
    { url: `/file/status`, method: 'GET', params, signal },
    options,
  )
}

export const getFileStatusQueryKey = (params?: FileStatusParams) => {
  return [`/file/status`, ...(params ? [params] : [])] as const
}

export const getFileStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof fileStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: FileStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFileStatusQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof fileStatus>>> = ({
    signal,
  }) => fileStatus(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof fileStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FileStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof fileStatus>>
>
export type FileStatusQueryError = ErrorType<unknown>

export function useFileStatus<
  TData = Awaited<ReturnType<typeof fileStatus>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | FileStatusParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileStatus>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileStatus>>,
          TError,
          Awaited<ReturnType<typeof fileStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFileStatus<
  TData = Awaited<ReturnType<typeof fileStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: FileStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileStatus>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileStatus>>,
          TError,
          Awaited<ReturnType<typeof fileStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFileStatus<
  TData = Awaited<ReturnType<typeof fileStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: FileStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useFileStatus<
  TData = Awaited<ReturnType<typeof fileStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: FileStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFileStatusQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Write a log entry to the server logs
 */
export const appLog = (
  appLogBody: BodyType<AppLogBody>,
  params?: AppLogParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `/log`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: appLogBody,
      params,
      signal,
    },
    options,
  )
}

export const getAppLogMutationOptions = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof appLog>>,
    TError,
    { data: BodyType<AppLogBody>; params?: AppLogParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof appLog>>,
  TError,
  { data: BodyType<AppLogBody>; params?: AppLogParams },
  TContext
> => {
  const mutationKey = ['appLog']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof appLog>>,
    { data: BodyType<AppLogBody>; params?: AppLogParams }
  > = (props) => {
    const { data, params } = props ?? {}

    return appLog(data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AppLogMutationResult = NonNullable<
  Awaited<ReturnType<typeof appLog>>
>
export type AppLogMutationBody = BodyType<AppLogBody>
export type AppLogMutationError = ErrorType<BadRequestError>

export const useAppLog = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof appLog>>,
      TError,
      { data: BodyType<AppLogBody>; params?: AppLogParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof appLog>>,
  TError,
  { data: BodyType<AppLogBody>; params?: AppLogParams },
  TContext
> => {
  const mutationOptions = getAppLogMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * List all agents
 */
export const appAgents = (
  params?: AppAgentsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Agent[]>(
    { url: `/agent`, method: 'GET', params, signal },
    options,
  )
}

export const getAppAgentsQueryKey = (params?: AppAgentsParams) => {
  return [`/agent`, ...(params ? [params] : [])] as const
}

export const getAppAgentsQueryOptions = <
  TData = Awaited<ReturnType<typeof appAgents>>,
  TError = ErrorType<unknown>,
>(
  params?: AppAgentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof appAgents>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getAppAgentsQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof appAgents>>> = ({
    signal,
  }) => appAgents(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof appAgents>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AppAgentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof appAgents>>
>
export type AppAgentsQueryError = ErrorType<unknown>

export function useAppAgents<
  TData = Awaited<ReturnType<typeof appAgents>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | AppAgentsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof appAgents>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof appAgents>>,
          TError,
          Awaited<ReturnType<typeof appAgents>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAppAgents<
  TData = Awaited<ReturnType<typeof appAgents>>,
  TError = ErrorType<unknown>,
>(
  params?: AppAgentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof appAgents>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof appAgents>>,
          TError,
          Awaited<ReturnType<typeof appAgents>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useAppAgents<
  TData = Awaited<ReturnType<typeof appAgents>>,
  TError = ErrorType<unknown>,
>(
  params?: AppAgentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof appAgents>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useAppAgents<
  TData = Awaited<ReturnType<typeof appAgents>>,
  TError = ErrorType<unknown>,
>(
  params?: AppAgentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof appAgents>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getAppAgentsQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get MCP server status
 */
export const mcpStatus = (
  params?: McpStatusParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<McpStatus200>(
    { url: `/mcp`, method: 'GET', params, signal },
    options,
  )
}

export const getMcpStatusQueryKey = (params?: McpStatusParams) => {
  return [`/mcp`, ...(params ? [params] : [])] as const
}

export const getMcpStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof mcpStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: McpStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof mcpStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getMcpStatusQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof mcpStatus>>> = ({
    signal,
  }) => mcpStatus(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof mcpStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type McpStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof mcpStatus>>
>
export type McpStatusQueryError = ErrorType<unknown>

export function useMcpStatus<
  TData = Awaited<ReturnType<typeof mcpStatus>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | McpStatusParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof mcpStatus>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpStatus>>,
          TError,
          Awaited<ReturnType<typeof mcpStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useMcpStatus<
  TData = Awaited<ReturnType<typeof mcpStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: McpStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof mcpStatus>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof mcpStatus>>,
          TError,
          Awaited<ReturnType<typeof mcpStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useMcpStatus<
  TData = Awaited<ReturnType<typeof mcpStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: McpStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof mcpStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useMcpStatus<
  TData = Awaited<ReturnType<typeof mcpStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: McpStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof mcpStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getMcpStatusQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get LSP server status
 */
export const lspStatus = (
  params?: LspStatusParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LSPStatus[]>(
    { url: `/lsp`, method: 'GET', params, signal },
    options,
  )
}

export const getLspStatusQueryKey = (params?: LspStatusParams) => {
  return [`/lsp`, ...(params ? [params] : [])] as const
}

export const getLspStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof lspStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: LspStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lspStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getLspStatusQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof lspStatus>>> = ({
    signal,
  }) => lspStatus(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof lspStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LspStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof lspStatus>>
>
export type LspStatusQueryError = ErrorType<unknown>

export function useLspStatus<
  TData = Awaited<ReturnType<typeof lspStatus>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | LspStatusParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lspStatus>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lspStatus>>,
          TError,
          Awaited<ReturnType<typeof lspStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useLspStatus<
  TData = Awaited<ReturnType<typeof lspStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: LspStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lspStatus>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lspStatus>>,
          TError,
          Awaited<ReturnType<typeof lspStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useLspStatus<
  TData = Awaited<ReturnType<typeof lspStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: LspStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lspStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useLspStatus<
  TData = Awaited<ReturnType<typeof lspStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: LspStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof lspStatus>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getLspStatusQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Get formatter status
 */
export const formatterStatus = (
  params?: FormatterStatusParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<FormatterStatus[]>(
    { url: `/formatter`, method: 'GET', params, signal },
    options,
  )
}

export const getFormatterStatusQueryKey = (params?: FormatterStatusParams) => {
  return [`/formatter`, ...(params ? [params] : [])] as const
}

export const getFormatterStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof formatterStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: FormatterStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof formatterStatus>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getFormatterStatusQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof formatterStatus>>> = ({
    signal,
  }) => formatterStatus(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof formatterStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FormatterStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof formatterStatus>>
>
export type FormatterStatusQueryError = ErrorType<unknown>

export function useFormatterStatus<
  TData = Awaited<ReturnType<typeof formatterStatus>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | FormatterStatusParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof formatterStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof formatterStatus>>,
          TError,
          Awaited<ReturnType<typeof formatterStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFormatterStatus<
  TData = Awaited<ReturnType<typeof formatterStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: FormatterStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof formatterStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof formatterStatus>>,
          TError,
          Awaited<ReturnType<typeof formatterStatus>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useFormatterStatus<
  TData = Awaited<ReturnType<typeof formatterStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: FormatterStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof formatterStatus>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useFormatterStatus<
  TData = Awaited<ReturnType<typeof formatterStatus>>,
  TError = ErrorType<unknown>,
>(
  params?: FormatterStatusParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof formatterStatus>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getFormatterStatusQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Append prompt to the TUI
 */
export const tuiAppendPrompt = (
  tuiAppendPromptBody: BodyType<TuiAppendPromptBody>,
  params?: TuiAppendPromptParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `/tui/append-prompt`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: tuiAppendPromptBody,
      params,
      signal,
    },
    options,
  )
}

export const getTuiAppendPromptMutationOptions = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tuiAppendPrompt>>,
    TError,
    { data: BodyType<TuiAppendPromptBody>; params?: TuiAppendPromptParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tuiAppendPrompt>>,
  TError,
  { data: BodyType<TuiAppendPromptBody>; params?: TuiAppendPromptParams },
  TContext
> => {
  const mutationKey = ['tuiAppendPrompt']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tuiAppendPrompt>>,
    { data: BodyType<TuiAppendPromptBody>; params?: TuiAppendPromptParams }
  > = (props) => {
    const { data, params } = props ?? {}

    return tuiAppendPrompt(data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TuiAppendPromptMutationResult = NonNullable<
  Awaited<ReturnType<typeof tuiAppendPrompt>>
>
export type TuiAppendPromptMutationBody = BodyType<TuiAppendPromptBody>
export type TuiAppendPromptMutationError = ErrorType<BadRequestError>

export const useTuiAppendPrompt = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tuiAppendPrompt>>,
      TError,
      { data: BodyType<TuiAppendPromptBody>; params?: TuiAppendPromptParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tuiAppendPrompt>>,
  TError,
  { data: BodyType<TuiAppendPromptBody>; params?: TuiAppendPromptParams },
  TContext
> => {
  const mutationOptions = getTuiAppendPromptMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Open the help dialog
 */
export const tuiOpenHelp = (
  params?: TuiOpenHelpParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/tui/open-help`, method: 'POST', params, signal },
    options,
  )
}

export const getTuiOpenHelpMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tuiOpenHelp>>,
    TError,
    { params?: TuiOpenHelpParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tuiOpenHelp>>,
  TError,
  { params?: TuiOpenHelpParams },
  TContext
> => {
  const mutationKey = ['tuiOpenHelp']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tuiOpenHelp>>,
    { params?: TuiOpenHelpParams }
  > = (props) => {
    const { params } = props ?? {}

    return tuiOpenHelp(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TuiOpenHelpMutationResult = NonNullable<
  Awaited<ReturnType<typeof tuiOpenHelp>>
>

export type TuiOpenHelpMutationError = ErrorType<unknown>

export const useTuiOpenHelp = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tuiOpenHelp>>,
      TError,
      { params?: TuiOpenHelpParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tuiOpenHelp>>,
  TError,
  { params?: TuiOpenHelpParams },
  TContext
> => {
  const mutationOptions = getTuiOpenHelpMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Open the session dialog
 */
export const tuiOpenSessions = (
  params?: TuiOpenSessionsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/tui/open-sessions`, method: 'POST', params, signal },
    options,
  )
}

export const getTuiOpenSessionsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tuiOpenSessions>>,
    TError,
    { params?: TuiOpenSessionsParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tuiOpenSessions>>,
  TError,
  { params?: TuiOpenSessionsParams },
  TContext
> => {
  const mutationKey = ['tuiOpenSessions']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tuiOpenSessions>>,
    { params?: TuiOpenSessionsParams }
  > = (props) => {
    const { params } = props ?? {}

    return tuiOpenSessions(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TuiOpenSessionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof tuiOpenSessions>>
>

export type TuiOpenSessionsMutationError = ErrorType<unknown>

export const useTuiOpenSessions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tuiOpenSessions>>,
      TError,
      { params?: TuiOpenSessionsParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tuiOpenSessions>>,
  TError,
  { params?: TuiOpenSessionsParams },
  TContext
> => {
  const mutationOptions = getTuiOpenSessionsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Open the theme dialog
 */
export const tuiOpenThemes = (
  params?: TuiOpenThemesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/tui/open-themes`, method: 'POST', params, signal },
    options,
  )
}

export const getTuiOpenThemesMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tuiOpenThemes>>,
    TError,
    { params?: TuiOpenThemesParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tuiOpenThemes>>,
  TError,
  { params?: TuiOpenThemesParams },
  TContext
> => {
  const mutationKey = ['tuiOpenThemes']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tuiOpenThemes>>,
    { params?: TuiOpenThemesParams }
  > = (props) => {
    const { params } = props ?? {}

    return tuiOpenThemes(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TuiOpenThemesMutationResult = NonNullable<
  Awaited<ReturnType<typeof tuiOpenThemes>>
>

export type TuiOpenThemesMutationError = ErrorType<unknown>

export const useTuiOpenThemes = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tuiOpenThemes>>,
      TError,
      { params?: TuiOpenThemesParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tuiOpenThemes>>,
  TError,
  { params?: TuiOpenThemesParams },
  TContext
> => {
  const mutationOptions = getTuiOpenThemesMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Open the model dialog
 */
export const tuiOpenModels = (
  params?: TuiOpenModelsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/tui/open-models`, method: 'POST', params, signal },
    options,
  )
}

export const getTuiOpenModelsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tuiOpenModels>>,
    TError,
    { params?: TuiOpenModelsParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tuiOpenModels>>,
  TError,
  { params?: TuiOpenModelsParams },
  TContext
> => {
  const mutationKey = ['tuiOpenModels']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tuiOpenModels>>,
    { params?: TuiOpenModelsParams }
  > = (props) => {
    const { params } = props ?? {}

    return tuiOpenModels(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TuiOpenModelsMutationResult = NonNullable<
  Awaited<ReturnType<typeof tuiOpenModels>>
>

export type TuiOpenModelsMutationError = ErrorType<unknown>

export const useTuiOpenModels = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tuiOpenModels>>,
      TError,
      { params?: TuiOpenModelsParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tuiOpenModels>>,
  TError,
  { params?: TuiOpenModelsParams },
  TContext
> => {
  const mutationOptions = getTuiOpenModelsMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Submit the prompt
 */
export const tuiSubmitPrompt = (
  params?: TuiSubmitPromptParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/tui/submit-prompt`, method: 'POST', params, signal },
    options,
  )
}

export const getTuiSubmitPromptMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tuiSubmitPrompt>>,
    TError,
    { params?: TuiSubmitPromptParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tuiSubmitPrompt>>,
  TError,
  { params?: TuiSubmitPromptParams },
  TContext
> => {
  const mutationKey = ['tuiSubmitPrompt']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tuiSubmitPrompt>>,
    { params?: TuiSubmitPromptParams }
  > = (props) => {
    const { params } = props ?? {}

    return tuiSubmitPrompt(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TuiSubmitPromptMutationResult = NonNullable<
  Awaited<ReturnType<typeof tuiSubmitPrompt>>
>

export type TuiSubmitPromptMutationError = ErrorType<unknown>

export const useTuiSubmitPrompt = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tuiSubmitPrompt>>,
      TError,
      { params?: TuiSubmitPromptParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tuiSubmitPrompt>>,
  TError,
  { params?: TuiSubmitPromptParams },
  TContext
> => {
  const mutationOptions = getTuiSubmitPromptMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Clear the prompt
 */
export const tuiClearPrompt = (
  params?: TuiClearPromptParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    { url: `/tui/clear-prompt`, method: 'POST', params, signal },
    options,
  )
}

export const getTuiClearPromptMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tuiClearPrompt>>,
    TError,
    { params?: TuiClearPromptParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tuiClearPrompt>>,
  TError,
  { params?: TuiClearPromptParams },
  TContext
> => {
  const mutationKey = ['tuiClearPrompt']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tuiClearPrompt>>,
    { params?: TuiClearPromptParams }
  > = (props) => {
    const { params } = props ?? {}

    return tuiClearPrompt(params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TuiClearPromptMutationResult = NonNullable<
  Awaited<ReturnType<typeof tuiClearPrompt>>
>

export type TuiClearPromptMutationError = ErrorType<unknown>

export const useTuiClearPrompt = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tuiClearPrompt>>,
      TError,
      { params?: TuiClearPromptParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tuiClearPrompt>>,
  TError,
  { params?: TuiClearPromptParams },
  TContext
> => {
  const mutationOptions = getTuiClearPromptMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Execute a TUI command (e.g. agent_cycle)
 */
export const tuiExecuteCommand = (
  tuiExecuteCommandBody: BodyType<TuiExecuteCommandBody>,
  params?: TuiExecuteCommandParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `/tui/execute-command`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: tuiExecuteCommandBody,
      params,
      signal,
    },
    options,
  )
}

export const getTuiExecuteCommandMutationOptions = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tuiExecuteCommand>>,
    TError,
    { data: BodyType<TuiExecuteCommandBody>; params?: TuiExecuteCommandParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tuiExecuteCommand>>,
  TError,
  { data: BodyType<TuiExecuteCommandBody>; params?: TuiExecuteCommandParams },
  TContext
> => {
  const mutationKey = ['tuiExecuteCommand']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tuiExecuteCommand>>,
    { data: BodyType<TuiExecuteCommandBody>; params?: TuiExecuteCommandParams }
  > = (props) => {
    const { data, params } = props ?? {}

    return tuiExecuteCommand(data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TuiExecuteCommandMutationResult = NonNullable<
  Awaited<ReturnType<typeof tuiExecuteCommand>>
>
export type TuiExecuteCommandMutationBody = BodyType<TuiExecuteCommandBody>
export type TuiExecuteCommandMutationError = ErrorType<BadRequestError>

export const useTuiExecuteCommand = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tuiExecuteCommand>>,
      TError,
      {
        data: BodyType<TuiExecuteCommandBody>
        params?: TuiExecuteCommandParams
      },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tuiExecuteCommand>>,
  TError,
  { data: BodyType<TuiExecuteCommandBody>; params?: TuiExecuteCommandParams },
  TContext
> => {
  const mutationOptions = getTuiExecuteCommandMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Show a toast notification in the TUI
 */
export const tuiShowToast = (
  tuiShowToastBody: BodyType<TuiShowToastBody>,
  params?: TuiShowToastParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `/tui/show-toast`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: tuiShowToastBody,
      params,
      signal,
    },
    options,
  )
}

export const getTuiShowToastMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tuiShowToast>>,
    TError,
    { data: BodyType<TuiShowToastBody>; params?: TuiShowToastParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tuiShowToast>>,
  TError,
  { data: BodyType<TuiShowToastBody>; params?: TuiShowToastParams },
  TContext
> => {
  const mutationKey = ['tuiShowToast']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tuiShowToast>>,
    { data: BodyType<TuiShowToastBody>; params?: TuiShowToastParams }
  > = (props) => {
    const { data, params } = props ?? {}

    return tuiShowToast(data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TuiShowToastMutationResult = NonNullable<
  Awaited<ReturnType<typeof tuiShowToast>>
>
export type TuiShowToastMutationBody = BodyType<TuiShowToastBody>
export type TuiShowToastMutationError = ErrorType<unknown>

export const useTuiShowToast = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tuiShowToast>>,
      TError,
      { data: BodyType<TuiShowToastBody>; params?: TuiShowToastParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tuiShowToast>>,
  TError,
  { data: BodyType<TuiShowToastBody>; params?: TuiShowToastParams },
  TContext
> => {
  const mutationOptions = getTuiShowToastMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Publish a TUI event
 */
export const tuiPublish = (
  tuiPublishBody: BodyType<TuiPublishBody>,
  params?: TuiPublishParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `/tui/publish`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: tuiPublishBody,
      params,
      signal,
    },
    options,
  )
}

export const getTuiPublishMutationOptions = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tuiPublish>>,
    TError,
    { data: BodyType<TuiPublishBody>; params?: TuiPublishParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tuiPublish>>,
  TError,
  { data: BodyType<TuiPublishBody>; params?: TuiPublishParams },
  TContext
> => {
  const mutationKey = ['tuiPublish']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tuiPublish>>,
    { data: BodyType<TuiPublishBody>; params?: TuiPublishParams }
  > = (props) => {
    const { data, params } = props ?? {}

    return tuiPublish(data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TuiPublishMutationResult = NonNullable<
  Awaited<ReturnType<typeof tuiPublish>>
>
export type TuiPublishMutationBody = BodyType<TuiPublishBody>
export type TuiPublishMutationError = ErrorType<BadRequestError>

export const useTuiPublish = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tuiPublish>>,
      TError,
      { data: BodyType<TuiPublishBody>; params?: TuiPublishParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tuiPublish>>,
  TError,
  { data: BodyType<TuiPublishBody>; params?: TuiPublishParams },
  TContext
> => {
  const mutationOptions = getTuiPublishMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get the next TUI request from the queue
 */
export const tuiControlNext = (
  params?: TuiControlNextParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TuiControlNext200>(
    { url: `/tui/control/next`, method: 'GET', params, signal },
    options,
  )
}

export const getTuiControlNextQueryKey = (params?: TuiControlNextParams) => {
  return [`/tui/control/next`, ...(params ? [params] : [])] as const
}

export const getTuiControlNextQueryOptions = <
  TData = Awaited<ReturnType<typeof tuiControlNext>>,
  TError = ErrorType<unknown>,
>(
  params?: TuiControlNextParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof tuiControlNext>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getTuiControlNextQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof tuiControlNext>>> = ({
    signal,
  }) => tuiControlNext(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof tuiControlNext>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type TuiControlNextQueryResult = NonNullable<
  Awaited<ReturnType<typeof tuiControlNext>>
>
export type TuiControlNextQueryError = ErrorType<unknown>

export function useTuiControlNext<
  TData = Awaited<ReturnType<typeof tuiControlNext>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | TuiControlNextParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof tuiControlNext>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof tuiControlNext>>,
          TError,
          Awaited<ReturnType<typeof tuiControlNext>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useTuiControlNext<
  TData = Awaited<ReturnType<typeof tuiControlNext>>,
  TError = ErrorType<unknown>,
>(
  params?: TuiControlNextParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof tuiControlNext>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof tuiControlNext>>,
          TError,
          Awaited<ReturnType<typeof tuiControlNext>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useTuiControlNext<
  TData = Awaited<ReturnType<typeof tuiControlNext>>,
  TError = ErrorType<unknown>,
>(
  params?: TuiControlNextParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof tuiControlNext>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useTuiControlNext<
  TData = Awaited<ReturnType<typeof tuiControlNext>>,
  TError = ErrorType<unknown>,
>(
  params?: TuiControlNextParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof tuiControlNext>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getTuiControlNextQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Submit a response to the TUI request queue
 */
export const tuiControlResponse = (
  tuiControlResponseBody: BodyType<unknown>,
  params?: TuiControlResponseParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<boolean>(
    {
      url: `/tui/control/response`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: tuiControlResponseBody,
      params,
      signal,
    },
    options,
  )
}

export const getTuiControlResponseMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof tuiControlResponse>>,
    TError,
    { data: BodyType<unknown>; params?: TuiControlResponseParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof tuiControlResponse>>,
  TError,
  { data: BodyType<unknown>; params?: TuiControlResponseParams },
  TContext
> => {
  const mutationKey = ['tuiControlResponse']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof tuiControlResponse>>,
    { data: BodyType<unknown>; params?: TuiControlResponseParams }
  > = (props) => {
    const { data, params } = props ?? {}

    return tuiControlResponse(data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type TuiControlResponseMutationResult = NonNullable<
  Awaited<ReturnType<typeof tuiControlResponse>>
>
export type TuiControlResponseMutationBody = BodyType<unknown>
export type TuiControlResponseMutationError = ErrorType<unknown>

export const useTuiControlResponse = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof tuiControlResponse>>,
      TError,
      { data: BodyType<unknown>; params?: TuiControlResponseParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof tuiControlResponse>>,
  TError,
  { data: BodyType<unknown>; params?: TuiControlResponseParams },
  TContext
> => {
  const mutationOptions = getTuiControlResponseMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Set authentication credentials
 */
export const authSet = (
  id: string,
  auth: BodyType<Auth>,
  params?: AuthSetParams,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<boolean>(
    {
      url: `/auth/${id}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: auth,
      params,
    },
    options,
  )
}

export const getAuthSetMutationOptions = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authSet>>,
    TError,
    { id: string; data: BodyType<Auth>; params?: AuthSetParams },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof authSet>>,
  TError,
  { id: string; data: BodyType<Auth>; params?: AuthSetParams },
  TContext
> => {
  const mutationKey = ['authSet']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authSet>>,
    { id: string; data: BodyType<Auth>; params?: AuthSetParams }
  > = (props) => {
    const { id, data, params } = props ?? {}

    return authSet(id, data, params, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AuthSetMutationResult = NonNullable<
  Awaited<ReturnType<typeof authSet>>
>
export type AuthSetMutationBody = BodyType<Auth>
export type AuthSetMutationError = ErrorType<BadRequestError>

export const useAuthSet = <
  TError = ErrorType<BadRequestError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof authSet>>,
      TError,
      { id: string; data: BodyType<Auth>; params?: AuthSetParams },
      TContext
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof authSet>>,
  TError,
  { id: string; data: BodyType<Auth>; params?: AuthSetParams },
  TContext
> => {
  const mutationOptions = getAuthSetMutationOptions(options)

  return useMutation(mutationOptions, queryClient)
}
/**
 * Get events
 */
export const eventSubscribe = (
  params?: EventSubscribeParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Event>(
    { url: `/event`, method: 'GET', params, signal },
    options,
  )
}

export const getEventSubscribeQueryKey = (params?: EventSubscribeParams) => {
  return [`/event`, ...(params ? [params] : [])] as const
}

export const getEventSubscribeQueryOptions = <
  TData = Awaited<ReturnType<typeof eventSubscribe>>,
  TError = ErrorType<unknown>,
>(
  params?: EventSubscribeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventSubscribe>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getEventSubscribeQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof eventSubscribe>>> = ({
    signal,
  }) => eventSubscribe(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof eventSubscribe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type EventSubscribeQueryResult = NonNullable<
  Awaited<ReturnType<typeof eventSubscribe>>
>
export type EventSubscribeQueryError = ErrorType<unknown>

export function useEventSubscribe<
  TData = Awaited<ReturnType<typeof eventSubscribe>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | EventSubscribeParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventSubscribe>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventSubscribe>>,
          TError,
          Awaited<ReturnType<typeof eventSubscribe>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useEventSubscribe<
  TData = Awaited<ReturnType<typeof eventSubscribe>>,
  TError = ErrorType<unknown>,
>(
  params?: EventSubscribeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventSubscribe>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof eventSubscribe>>,
          TError,
          Awaited<ReturnType<typeof eventSubscribe>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}
export function useEventSubscribe<
  TData = Awaited<ReturnType<typeof eventSubscribe>>,
  TError = ErrorType<unknown>,
>(
  params?: EventSubscribeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventSubscribe>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
}

export function useEventSubscribe<
  TData = Awaited<ReturnType<typeof eventSubscribe>>,
  TError = ErrorType<unknown>,
>(
  params?: EventSubscribeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof eventSubscribe>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>
} {
  const queryOptions = getEventSubscribeQueryOptions(params, options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> }

  query.queryKey = queryOptions.queryKey

  return query
}
